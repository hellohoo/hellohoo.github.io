<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MPR实现过程</title>
    <url>/2021/03/15/MPR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="MPR的介绍"><a href="#MPR的介绍" class="headerlink" title="MPR的介绍"></a>MPR的介绍</h2><p>MPR(multi-planner reformation)也称多平面重建，多重面重建是将扫描范围内所有的轴位图像叠加起来再对某些标线标定的重组线所指定的组织进行冠状、矢状位、任意角度斜位图像重组。MPR是CT三维数据呈现的重要内容，其在三维数据的任一点空间位置，采用XY、XZ和YZ三个平面切空间数据得到三个切面分别为轴状面、冠状面和矢状面，而且X/Y/Z三个轴可以绕三维坐标原点任意旋转。</p>
<p><em><span id="more"></span></em></p>
<p>MPR 的<strong>优点</strong></p>
<ul>
<li>能任意产生新的断层图像，而无需重复扫描。</li>
<li>曲面重组能在一幅图像里展开显示弯曲物体的生长。</li>
</ul>
<p>MPR的<strong>缺点</strong></p>
<ul>
<li>难以表达复杂的空间结构。</li>
<li>曲面重组易造成假阳性。</li>
</ul>
<h2 id="实验工具及配置"><a href="#实验工具及配置" class="headerlink" title="实验工具及配置"></a>实验工具及配置</h2><blockquote>
<p>平台：Windows 10</p>
<p>数据集：<a href="https://promise12.grand-challenge.org/Home/">Promise12</a> 也可以参考 <a href="https://my.oschina.net/u/4579165/blog/4344038">医学影像公开数据集（续）</a></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">软件</th>
<th align="center">版本</th>
<th align="center">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ITK</td>
<td align="center">4.13.2</td>
<td align="center"><a href="https://itk.org/download/">https://itk.org/download/</a></td>
</tr>
<tr>
<td align="center">VTK</td>
<td align="center">8.2.0</td>
<td align="center"><a href="https://vtk.org/download/">https://vtk.org/download/</a></td>
</tr>
<tr>
<td align="center">CMake</td>
<td align="center">3.14.0</td>
<td align="center"><a href="https://cmake.org/download/">https://cmake.org/download/</a></td>
</tr>
<tr>
<td align="center">Qt</td>
<td align="center">5.12.0</td>
<td align="center"><a href="https://www.qt.io/download">https://www.qt.io/download</a></td>
</tr>
<tr>
<td align="center">Visual Studio</td>
<td align="center">2017_64 bit</td>
<td align="center"><a href="https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/">https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/</a></td>
</tr>
</tbody></table>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><h4 id="安装VS2017"><a href="#安装VS2017" class="headerlink" title="安装VS2017"></a>安装VS2017</h4><p>参考博客：<a href="https://blog.csdn.net/qq_36556893/article/details/79430133">VS2017的安装与应用</a></p>
<h4 id="安装Qt"><a href="#安装Qt" class="headerlink" title="安装Qt"></a>安装Qt</h4><p>参考博客：<a href="https://blog.csdn.net/gaojixu/article/details/82185694">Qt的安装与VS2017的配置</a></p>
<h4 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h4><p>参考博客：<a href="https://blog.csdn.net/github_35160620/article/details/52365824?utm_source=blogxgwz0">Windows系统 安装 CMake</a></p>
<h4 id="安装VTK"><a href="#安装VTK" class="headerlink" title="安装VTK"></a>安装VTK</h4><p>参考博客：</p>
<p><a href="https://blog.csdn.net/jepco1/article/details/80628026">VTK8.1 在 Qt5.9 环境下的配置、编译和安装</a></p>
<p><a href="https://blog.csdn.net/hrq3333/article/details/81260963">VS2017动态编译VTK8.1.1</a></p>
<h4 id="安装ITK"><a href="#安装ITK" class="headerlink" title="安装ITK"></a>安装ITK</h4><p>参考博客：</p>
<p><a href="https://blog.csdn.net/yu253/article/details/78412307?utm_source=blogxgwz0">ITK4.12+VS2015配置详解</a></p>
<p><a href="https://blog.csdn.net/numit/article/details/9985045">Qt VTK ITK安装与测试（三）ITK的安装与测试</a></p>
<h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><blockquote>
<p>参考博客：<a href="https://blog.csdn.net/seugxf/article/details/105201516">基于VTK的MPR实现</a></p>
</blockquote>
<p>将MPR压缩包解压，并新建install和TestData文件夹。</p>
<img src="/2021/03/15/MPR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/image-20210315092535090.png" class="" title="MPR文件夹下新建">

<p>打开CMake，source code路径即为MPR/source，build路径即为MPR/build。</p>
<img src="/2021/03/15/MPR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/image-20210315092853496.png" class="" title="设置source和build路径">

<p>点击configure按钮，使用本地编译器，选择Visual Studio 15 2017，并选择x64后点击Finish，之后会出现一片红色，将其中CMAKE_INSTALL_PREFIX的路径改为新建的MPR/install，并选择ItkVtkGlue模块。</p>
<img src="/2021/03/15/MPR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/image-20210315092827410.png" class="" title="配置">

<p>继续configure，直到无红色出现，点击generate。</p>
<p>generate结束后，打开vs2017，找到build下的<code>QtVTKRenderWindows.sln</code>文件选择打开，并将<code>QtVTKRenderWindows</code>设为启动项目，点击本地Windows调试器即可。</p>
<img src="/2021/03/15/MPR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/image-20210315094459509.png" class="" title="设置为启动项目">

<h3 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h3><p>将三个面板的初始位置均设置为0，即体数据的三个边缘，同时将它们的颜色分别设计为红、绿、蓝三种颜色，与后面的映射图像窗口的颜色是对应的。</p>
<p>初始界面：</p>
<img src="/2021/03/15/MPR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/image-20210315094853813.png" class="" title="初始界面">

<p>旋转切面：</p>
<img src="/2021/03/15/MPR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/image-20210315094945787.png" class="" title="旋转切面">

<p>像素点的三维坐标与灰度值信息的显示：</p>
<img src="/2021/03/15/MPR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/image-20210315095034822.png" class="" title="坐标及灰度信息显示">

<p>灰度变化：</p>
<img src="/2021/03/15/MPR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/image-20210315095104254.png" class="" title="灰度变化">



]]></content>
      <categories>
        <category>技术</category>
        <category>VTK</category>
        <category>ITK</category>
      </categories>
      <tags>
        <tag>MPR</tag>
        <tag>VTK</tag>
        <tag>ITK</tag>
        <tag>技术</tag>
        <tag>医疗影像</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac的Rodin安装教程</title>
    <url>/2021/03/24/Mac%E7%9A%84Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>上篇文章写的是Windows 10下的Rodin安装，但由于Windows电脑过于沉重，而且续航不行，难以维持2个半小时的课程，故选择在Mac上安装。</p>
<p><em><span id="more"></span></em></p>
<h2 id="软件列表"><a href="#软件列表" class="headerlink" title="软件列表"></a>软件列表</h2><blockquote>
<p>系统：macOS Big Sur 11.2.3 </p>
<p>Rodin 3.5 下载地址：<a href="https://sourceforge.net/projects/rodin-b-sharp/files/Core_Rodin_Platform/3.5/">https://sourceforge.net/projects/rodin-b-sharp/files/Core_Rodin_Platform/3.5/</a></p>
</blockquote>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="安装JDK-8"><a href="#安装JDK-8" class="headerlink" title="安装JDK 8"></a>安装JDK 8</h3><h4 id="下载JDK-8"><a href="#下载JDK-8" class="headerlink" title="下载JDK 8"></a>下载JDK 8</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>在Mac上直接<code>terminal</code>中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install corretto8</span><br></pre></td></tr></table></figure>

<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>在IDEA中点击<code>File</code>-<code>Project Sturcture</code>:</p>
<img src="/2021/03/24/Mac%E7%9A%84Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/1.png" class="" title="打开Project Structure">

<p>点击右上角文件夹图标：</p>
<img src="/2021/03/24/Mac%E7%9A%84Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/2.png" class="" title="点击右上角文件夹图标">

<p>点击<code>Download JDK</code>：</p>
<img src="/2021/03/24/Mac%E7%9A%84Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/3.png" class="" title="选择Version为1.8">

<h4 id="测试JDK-8是否安装成功"><a href="#测试JDK-8是否安装成功" class="headerlink" title="测试JDK 8是否安装成功"></a>测试JDK 8是否安装成功</h4><p>输入以下命令不报错即成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line">javac</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h3 id="安装Rodin"><a href="#安装Rodin" class="headerlink" title="安装Rodin"></a>安装Rodin</h3><blockquote>
<h4 id="macOS-caveat"><a href="#macOS-caveat" class="headerlink" title="macOS caveat"></a>macOS caveat</h4><p>The Rodin application is not notarized. This means that when you download it from SourceForge, macOS will quarantine the application and tell you that it is broken. Just run the command <code>xattr -rc Rodin.app</code> in a Terminal to remove the quarantine tag.</p>
</blockquote>
<p>Rodin的官网有提示，下载后解压出现的<code>Rodin.app</code>直接点击会报错，需要在<code>Rodin.app</code>路径下打开终端输入<code>xattr -rc Rodin.app</code> 命令。</p>
<p>但是又继续报错：</p>
<img src="/2021/03/24/Mac%E7%9A%84Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/4.jpeg" class="" title="无法创建jvm">

<p>问题是无法创建JVM，因为网络上关于Rodin的教程本来就少，Mac的更少了，但是它和eclipse是一体的，所以我就去找了eclipse报该错误的原因，果然找到很多，发现是需要添加<code>-vm</code>。</p>
<p>进入Rodin.app路径下，因为我直接把它拉进Applications里，所以在终端直接输入以下指令进入Contents文件夹下修改<code>Info.plist</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;Applications&#x2F;rodin.app&#x2F;Contents</span><br><span class="line">vim Info.plist</span><br></pre></td></tr></table></figure>

<p>发现有一段被注释掉了</p>
<img src="/2021/03/24/Mac%E7%9A%84Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/5.png" class="" title="被注释掉了">

<p>在终端中执行如下命令来获得JDK完整的安装路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;libexec&#x2F;java_home --verbose</span><br></pre></td></tr></table></figure>

<p>则可在<code>Info.plist</code>中将注释内容改为自己的安装路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;string&gt;-vm&lt;&#x2F;string&gt;&lt;string&gt;&#x2F;Users&#x2F;hoohoo&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;corretto-1.8.0_282&#x2F;Contents&#x2F;Home&#x2F;bin&#x2F;java&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>

<p>修改并保存，就可以成功启动Rodin了。</p>
<blockquote>
<p>安装插件等步骤详见上一篇文章：<a href="http://hellohoohoo.com/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/#more">Rodin安装教程（附java8安装教程）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
        <category>安装</category>
      </categories>
      <tags>
        <tag>Rodin</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Rodin安装教程（附java8安装教程）</title>
    <url>/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>由于本学期需要学习Event-B语言。</p>
<blockquote>
<p><em>Event-B</em>是一种基于传统的谓词演算和定理证明的形式化语言。</p>
</blockquote>
<p>需要使用Rodin进行开发，因为下载的是3.5版本的，所以需要8以上（包含）的JRE的版本。</p>
<p><em><span id="more"></span></em></p>
<h2 id="软件列表"><a href="#软件列表" class="headerlink" title="软件列表"></a>软件列表</h2><blockquote>
<p>系统：WIndows 10</p>
</blockquote>
<table>
<thead>
<tr>
<th>软件</th>
<th>安装地址</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 8</td>
<td><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></td>
</tr>
<tr>
<td>Rodin</td>
<td><a href="https://wiki.event-b.org/index.php/Main_Page">https://wiki.event-b.org/index.php/Main_Page</a></td>
</tr>
</tbody></table>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="安装JDK-8"><a href="#安装JDK-8" class="headerlink" title="安装JDK 8"></a>安装JDK 8</h3><h4 id="下载JDK-8"><a href="#下载JDK-8" class="headerlink" title="下载JDK 8"></a>下载JDK 8</h4><p>下载版本8需要登录oracle，没有账户的话可以注册一下。</p>
<p>打开下载后的<code>jdk-8u281-windows-x64.exe</code>文件：</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/1.png" class="" title="JDK 8安装界面">

<p>点击下一步，可以更改安装路径（也可以按默认路径直接下一步）：</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/2.png" class="" title="安装路径更改">

<p>更改安装路径：</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/3.png" class="" title="更改安装路径">

<p>点击下一步，更改目标文件夹路径（也可以按默认路径直接下一步）：</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/4.png" class="" title="目标文件夹路径">

<p>点击下一步后就安装成功了：</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/5.png" class="" title="安装成功">

<h4 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h4><p>右键<code>我的电脑</code>-<code>属性</code>：</p>
<p>并点击<code>高级系统设置</code></p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/6.png" class="" title="点击高级系统设置">

<p>点击<code>环境变量</code>：</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/7.png" class="" title="点击环境变量">

<p>点击<code>系统变量</code>-<code>新建</code>：</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/8.png" class="" title="新建JAVA_HOME">

<p>新建<code>JAVA_HOME</code>，变量值为安装的jdk目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变量名：JAVA_HOME</span><br><span class="line">变量值：D:\Program Files\Java\jdk1.8.0_281</span><br></pre></td></tr></table></figure>

<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/9.png" class="" title="新建环境变量JAVA_HOME">

<p>配置环境变量<code>Path</code>，双击Path，新建：</p>
<p>建议使用JAVA_HOME进行新建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br><span class="line">%JAVA_HOME%\jre\bin</span><br></pre></td></tr></table></figure>

<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/10.png" class="" title="配置环境变量Path">

<p>点击确定环境变量配置完成。</p>
<blockquote>
<p>关于CLASSPATH：<strong>在JDK1.5之后的版本，配置Java环境变量的时候我们不再需要配置classpath，只需要配置Java_Home以及path即可！</strong></p>
<p>参考博客：<a href="https://www.cnblogs.com/ideal-20/p/11050114.html">Java开发环境不再需要配置classpath！</a></p>
</blockquote>
<p>打开cmd分别输入以下三条指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line">javac</span><br><span class="line">java-version</span><br></pre></td></tr></table></figure>

<p>显示如下内容则jdk 8安装成功。</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/11.png" class="" title="输入JAVA">

<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/12.png" class="" title="输入java -version">

<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/13.png" class="" title="输入javac">

<h3 id="安装Rodin"><a href="#安装Rodin" class="headerlink" title="安装Rodin"></a>安装Rodin</h3><h4 id="下载Rodin"><a href="#下载Rodin" class="headerlink" title="下载Rodin"></a>下载Rodin</h4><p>Windows 10下选择<code>rodin-3.5.0.202009111309-74e0e4188-win32.win32.x86_64</code>：</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/14.png" class="" title="下载Rodin">

<p>下载解压后直接打开rodin.exe`:</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/15.png" class="" title="下载Rodin">

<p>点开后，Workspace可以默认路径也可以自己改路径：</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/16.png" class="" title="Workspace">

<p>打开后出现如下界面即为安装成功：</p>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/17.png" class="" title="安装成功">

<p>如果想要安装插件，点击<code>Help</code>-<code>Install New Software</code>：</p>
<p>在<code>Work with</code>里输入相应名称即可安装。</p>
<blockquote>
<p>安装插件过程较慢，可以搭梯子。</p>
</blockquote>
<img src="/2021/03/17/Rodin%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E9%99%84java8%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%89/18.png" class="" title="安装插件">]]></content>
      <categories>
        <category>技术</category>
        <category>安装</category>
      </categories>
      <tags>
        <tag>Rodin</tag>
        <tag>安装</tag>
        <tag>JDK</tag>
        <tag>Event-B</tag>
      </tags>
  </entry>
  <entry>
    <title>VR实现过程（使用VTK官方代码）</title>
    <url>/2021/03/26/VR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8VTK%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81%EF%BC%89/</url>
    <content><![CDATA[<h2 id="VR的介绍"><a href="#VR的介绍" class="headerlink" title="VR的介绍"></a>VR的介绍</h2><p>VR（Volume Rendering）也称为体绘制，是一种直接由三维数据场产生屏幕上二维图像的技术。</p>
<span id="more"></span>

<p>VR的优点：</p>
<ul>
<li>可以探索物体的内部结构</li>
<li>可以描述非常定形的物体</li>
<li>面绘制在这些方面比较弱</li>
</ul>
<p>VR的缺点：</p>
<ul>
<li>数据存储量大</li>
<li>计算时间较长</li>
</ul>
<h2 id="实验工具及配置"><a href="#实验工具及配置" class="headerlink" title="实验工具及配置"></a>实验工具及配置</h2><blockquote>
<p>平台：Windows 10</p>
<p>语言：C++</p>
<p>图像格式：MHD</p>
<p>数据集：使用的是VTK-Example中的<code>FullHead.mhd</code></p>
<p>​              也可以使用<a href="https://promise12.grand-challenge.org/Home/">Promise12</a> （可以参考 <a href="https://my.oschina.net/u/4579165/blog/4344038">医学影像公开数据集（续）</a>）等mhd格式数据</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">软件</th>
<th align="center">版本</th>
<th align="center">地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">VTK</td>
<td align="center">8.2.0</td>
<td align="center"><a href="https://vtk.org/download/">https://vtk.org/download/</a></td>
</tr>
<tr>
<td align="center">CMake</td>
<td align="center">3.14.0</td>
<td align="center"><a href="https://cmake.org/download/">https://cmake.org/download/</a></td>
</tr>
<tr>
<td align="center">Visual Studio</td>
<td align="center">2017_64 bit</td>
<td align="center"><a href="https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/">https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/</a></td>
</tr>
</tbody></table>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><h4 id="安装VS2017"><a href="#安装VS2017" class="headerlink" title="安装VS2017"></a>安装VS2017</h4><p>参考博客：<a href="https://blog.csdn.net/qq_36556893/article/details/79430133">VS2017的安装与应用</a></p>
<h4 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h4><p>参考博客：<a href="https://blog.csdn.net/github_35160620/article/details/52365824?utm_source=blogxgwz0">Windows系统 安装 CMake</a></p>
<h4 id="安装VTK"><a href="#安装VTK" class="headerlink" title="安装VTK"></a>安装VTK</h4><p>参考博客：</p>
<p>​    <a href="https://blog.csdn.net/jepco1/article/details/80628026">VTK8.1 在 Qt5.9 环境下的配置、编译和安装</a></p>
<p>​    <a href="https://blog.csdn.net/hrq3333/article/details/81260963">VS2017动态编译VTK8.1.1</a></p>
<h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><blockquote>
<p>参考：<a href="https://kitware.github.io/vtk-examples/site/Cxx/VolumeRendering/FixedPointVolumeRayCastMapperCT/">vtk-examples-FixedPointVolumeRayCastMapperCT</a></p>
</blockquote>
<p>进入VTK官网可以看到关于VR有许多例子，而且每个例子都会有示意图，选择了第一个<code>FixedPointVolumeRayCastMapperCT</code>。</p>
<ol>
<li>点击<a href="https://github.com/Kitware/vtk-examples/raw/gh-pages/Tarballs/FixedPointVolumeRayCastMapperCT.tar">here to download FixedPointVolumeRayCastMapperCT</a>后系统会自动下载，并解压：</li>
</ol>
<img src="/2021/03/26/VR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8VTK%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81%EF%BC%89/1.png" class="" title="下载源代码">

<ol start="2">
<li>该文件夹下包括<code>CMakeLists.txt</code>和<code>cxx</code>源文件和一个<code>build</code>文件夹：</li>
</ol>
<img src="/2021/03/26/VR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8VTK%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81%EF%BC%89/2.png" class="" title="文件夹">

<ol start="3">
<li>新建<code>source</code>文件夹和<code>testData</code>文件夹，并将<code>CMakeLists.txt</code>和<code>cxx</code>源文件移动到<code>source</code>文件：</li>
</ol>
<img src="/2021/03/26/VR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8VTK%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81%EF%BC%89/3.png" class="" title="新建文件夹">

<ol start="4">
<li>打开CMake，打开CMake，source code路径即为<code>VR/FixedPointVolumeRayCastMapperCT/source</code>，build路径即为<code>VR/FixedPointVolumeRayCastMapperCT/build</code>：</li>
</ol>
<img src="/2021/03/26/VR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8VTK%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81%EF%BC%89/4.png" class="" title="编译路径">

<ol start="5">
<li>点击<code>configure</code>按钮，使用本地编译器，选择<code>Visual Studio 15 2017</code>，并选择<code>x64</code>后点击<code>Finish</code>，之后会出现一片红色，将其中<code>CMAKE_INSTALL_PREFIX</code>的路径改为<code>VR/FixedPointVolumeRayCastMapperCT/build</code>：</li>
</ol>
<img src="/2021/03/26/VR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8VTK%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81%EF%BC%89/5.png" class="" title="选择编译器">

<img src="/2021/03/26/VR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8VTK%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81%EF%BC%89/6.png" class="" title="改路径">

<ol start="6">
<li>继续<code>configure</code>，直到无红色出现，点击<code>generate</code>，<code>generate</code>结束后，打开vs2017，找到<code>build</code>文件夹下的<code>FixedPointVolumeRayCastMapperCT.sln</code>文件选择打开，并将<code>**FixedPointVolumeRayCastMapperCT**</code>设为启动项目，点击本地Windows调试器即可运行。</li>
</ol>
<h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><blockquote>
<p>Example: FixedPointVolumeRayCastMapperCT -DICOM CTNeck -MIP 4096 1024</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-DICOM &lt;directory&gt;                             <span class="comment">// 使用的数据集为 DICOM 格式</span></span><br><span class="line">-VTI &lt;filename&gt;                                <span class="comment">// 使用的数据集为 VTI 格式</span></span><br><span class="line">-MHA &lt;filename&gt;                                <span class="comment">// 使用的数据集为 MHA 格式</span></span><br><span class="line">-DependentComponents                           <span class="comment">// 指定文件具有从属组件</span></span><br><span class="line">-Clip                                          <span class="comment">// 显示用于剪切卷的多维数据集小部件</span></span><br><span class="line">-MIP &lt;window&gt; &lt;level&gt;                          <span class="comment">// 使用最大强度投影方法</span></span><br><span class="line">-CompositeRamp &lt;window&gt; &lt;level&gt;                <span class="comment">// 是非着色合成</span></span><br><span class="line">-CompositeShadeRamp &lt;window&gt; &lt;level&gt;           <span class="comment">// 使用着色合成</span></span><br><span class="line">-CT_Skin                                       <span class="comment">// 适用于 DICOM 数据</span></span><br><span class="line">-CT_Bone                                       <span class="comment">// 适用于 DICOM 数据</span></span><br><span class="line">-CT_Muscle                                     <span class="comment">// 适用于 DICOM 数据</span></span><br><span class="line">-FrameRate &lt;rate&gt;                              <span class="comment">// 控制交互式渲染速率</span></span><br><span class="line">-DataReduction &lt;factor&gt;                        <span class="comment">// 在渲染前缩减数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li>必须使用<code>-DICOM</code>选项指定数据所在的目录，或使用<code>-VTI</code>或<code>-MHA</code>选项指定.VTI文件的路径。</li>
<li>默认情况下，程序假定文件具有独立组件，使用<code>-DependentComponents</code>指定文件具有从属组件。</li>
<li>使用<code>-Clip</code>选项显示用于剪切卷的多维数据集小部件。</li>
<li>将<code>-FrameRate</code>选项与所需的帧速率（以每秒帧数为单位）一起使用，以控制交互式渲染速率。</li>
<li>使用<code>-DataReduction</code>选项和缩减因子（大于零且小于1）在渲染前缩减数据。</li>
<li>使用其余选项之一指定混合函数和传递函数。<code>MIP</code>选项使用最大强度投影方法，而其他选项使用合成。</li>
<li><code>-CompositeRamp</code>选项是非着色合成，而其他合成选项使用着色。</li>
<li>注：<code>MIP</code>、<code>CompositeRamp</code>、<code>CompositeShadeRamp</code>、<code>CT_Skin</code>、<code>CT_Bone</code>和<code>CT_Muscle</code>适用于DICOM数据。<code>MIP</code>、<code>CompositeRamp</code>和<code>RGB_Composite</code>适用于RGB数据。</li>
</ul>
<h4 id="修改源代码"><a href="#修改源代码" class="headerlink" title="修改源代码"></a>修改源代码</h4><p>由于VTK官网是在Linux/macOS的终端运行，但已经在本机Windows 10下安装了全套的配置软件，故修改了其中一些代码，使其更直观操作。</p>
<p>源代码如下，并配置了相关判断代码（修改后将判断代码全部注释掉，用以自己直接修改参数），用来判断在终端中输入的参数值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parse the parameters</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">1</span>;                         <span class="comment">// 可以删去，因为不需要判断，所以计数器无用</span></span><br><span class="line">  <span class="keyword">char</span>* dirname = <span class="literal">NULL</span>;                  <span class="comment">// 如果使用的数据集为Dicom格式，则可修改NULL值为数据集文件夹地址</span></span><br><span class="line">  <span class="keyword">double</span> opacityWindow = <span class="number">4096</span>;           <span class="comment">// opacityWindow大小</span></span><br><span class="line">  <span class="keyword">double</span> opacityLevel = <span class="number">2048</span>;            <span class="comment">// opacityLevel大小</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* blendType</span></span><br><span class="line"><span class="comment">      根据参数修改为不同的数字，为不同的效果，其中：</span></span><br><span class="line"><span class="comment">      MIP：blendType = 0</span></span><br><span class="line"><span class="comment">      -CompositeRamp：blendType = 1</span></span><br><span class="line"><span class="comment">      -CompositeShadeRamp：blendType = 2</span></span><br><span class="line"><span class="comment">      -CT_Skin：blendType = 3</span></span><br><span class="line"><span class="comment">      -CT_Bone：blendType = 4</span></span><br><span class="line"><span class="comment">      -CT_Muscle：blendType = 5</span></span><br><span class="line"><span class="comment">      -RGB_Composite：blendType = 6</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> blendType = <span class="number">0</span>;   </span><br><span class="line">  <span class="keyword">int</span> clip = <span class="number">0</span>;                          <span class="comment">// 如果上文选择Clip选项，则clip = 1</span></span><br><span class="line">  <span class="keyword">double</span> reductionFactor = <span class="number">1.0</span>;          <span class="comment">// 参数范围在0-1，</span></span><br><span class="line">  <span class="keyword">double</span> frameRate = <span class="number">10.0</span>;               <span class="comment">// 控制交互式渲染速率，渲染前缩减数据</span></span><br><span class="line">  <span class="keyword">char</span>* fileName = <span class="number">0</span>;                    <span class="comment">// 如果为VTI格式或MHA/MHD格式，则可修改NULL值为数据文件地址</span></span><br><span class="line">  <span class="keyword">int</span> fileType = <span class="number">0</span>;                      <span class="comment">// 文件格式，可直接根据数据集文件进行输入，无需判断</span></span><br><span class="line">  <span class="keyword">bool</span> independentComponents = <span class="literal">true</span>;     <span class="comment">// 修改不同的数字为不同的效果，下文会有展示</span></span><br></pre></td></tr></table></figure>



<p>由于采用<code>Windows 10</code>系统，未使用终端，参数修改后如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parse the parameters</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> *dirname = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">double</span> opacityWindow = <span class="number">4096</span>;</span><br><span class="line">  <span class="keyword">double</span> opacityLevel = <span class="number">2048</span>;</span><br><span class="line">  <span class="keyword">int</span> blendType = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> clip = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">double</span> reductionFactor = <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">double</span> frameRate = <span class="number">10.0</span>;</span><br><span class="line">  <span class="keyword">char</span> *fileName=<span class="string">&quot;F://MPR//VR1//FixedPointVolumeRayCastMapperCT//FullHead.mhd&quot;</span>;</span><br><span class="line">  <span class="comment">// char *fileName = &quot;F://MPR//VR1//FixedPointVolumeRayCastMapperCT//TestData//Case00.mhd&quot;;</span></span><br><span class="line">  <span class="keyword">int</span> fileType= MHA_FILETYPE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> independentComponents=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>并将代码中判断参数代码直接注释掉，从<code>while ( count &lt; args )</code>一直到<code>if ( !dirname &amp;&amp; !fileName)</code>结束。</p>
<h3 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h3><p>当 <code>blendType</code> = 0时：</p>
<img src="/2021/03/26/VR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8VTK%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81%EF%BC%89/101.png" class="" title="blendType &#x3D; 0">

<p>使用<code>CT_Skin</code>参数时：</p>
<img src="/2021/03/26/VR%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8VTK%E5%AE%98%E6%96%B9%E4%BB%A3%E7%A0%81%EF%BC%89/100.png" class="" title="blendType &#x3D; 3">

]]></content>
      <categories>
        <category>技术</category>
        <category>VTK</category>
      </categories>
      <tags>
        <tag>VTK</tag>
        <tag>医学影像</tag>
      </tags>
  </entry>
  <entry>
    <title>《视觉SLAM十四讲 第2版》学习笔记 第2讲</title>
    <url>/2021/04/03/SLAM14/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2-%E7%AC%AC2%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E8%AE%B2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>从0到1，进步的阶梯。——Hoohoo</p>
</blockquote>
<span id="more"></span>

<p>之前买书的时候还没有到，用的就是第一版的电子书，有些内容也有改变，比如第2讲中的实验部分第1版使用的是Ubuntu14.04，而在第二版中已经使用了18.04，正好和我实验室电脑中装的一样，有些小确幸，当时没有赶时髦装20.04。</p>
<p>本讲开启了<strong>第1部分——数学基础</strong>，也是<strong>初识SLAM</strong>，那就让我们一起迈过0，进入1的世界吧！</p>
<h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><blockquote>
<p><strong>主要目标</strong></p>
<ol>
<li>理解一个视觉 SLAM 框架由哪几个模块组成，各模块的任务是什么。</li>
<li>搭建编程环境，为开发和实验做准备。</li>
<li>理解如何在 Linux 下编译并运行一个程序。如果它出了问题，我们又如何对它进 行调试。</li>
<li>掌握 cmake 的基本使用方法。</li>
</ol>
</blockquote>
<p>感知主要为“定位”和“建图”——可以看做感知的内外之分。</p>
<p>即：状态（位置）、环境（地图）。</p>
<p><strong>传感器</strong>主要分为两类：</p>
<ol>
<li>携带于机器人本体上</li>
<li>安装于环境中</li>
</ol>
<p>视觉SLAM主要是指如何用<strong>相机</strong>解决定位和建图问题。</p>
<h3 id="2-1-相机种类"><a href="#2-1-相机种类" class="headerlink" title="2.1 相机种类"></a>2.1 相机种类</h3><p>按照工作方式的不同，我们可以把相机分为三大类：<strong>单目（Monocular）</strong>、<strong>双目（Stereo）</strong>、<strong>深度（RGB-D）</strong>相机三大类。</p>
<h4 id="单目相机"><a href="#单目相机" class="headerlink" title="单目相机"></a>单目相机</h4><p>只有一个摄像头进行SLAM的做法成为单目SLAM。</p>
<p><strong>优点</strong>：传感器构成简单、成本特别低。</p>
<p><strong>缺点</strong>：平移之后才能计算深度、无法确定真实尺度，</p>
<p>数据：照片。</p>
<p>照片本质上是拍摄某个场景（Scene）在相机的成像平面上留下的一个<strong>投影</strong>。<strong>它以二维的形式记录了三维的世界</strong>。所以没有<strong>深度（距离）</strong>信息。</p>
<blockquote>
<p>距离在SLAM中非常重要，因为人类的眼睛可以大概分辨出，但是机器无法分辨和估计。</p>
</blockquote>
<p>由于单目相机拍摄的图像只是三维空间的二维投影，所以必须改变相机<strong>视角</strong>才能恢复三维结构。</p>
<p>需要拍许多张不同视角的照片进行估计。</p>
<p>我们移动相机，才能估计它的运动（Motion），同时估计场景中物体的远近和大小，称之为<strong>结构</strong>。</p>
<p>其中，近处的物体移动快，远处的物体移动慢，极远处（无穷远处）的物体——比如太阳月亮之类的看上去是不动的。于是相机在移动时，这些物体在图像上的运动就形成了<strong>视差（Disparity）</strong>。</p>
<p>但是即使我们知道了物体远近，它们只是一个相对的值。</p>
<blockquote>
<p>想象我们在看电影时候，虽然能够知道电影场景中哪些物体比另一些大，但我们无法确定电影里那些物体的“真实尺度”:那些大楼是真实的高楼大厦，还是放在桌上的模型？而摧毁大厦的是真实怪兽， 还是穿着特摄服装的演员？直观地说，如果把相机的运动和场景大小同时放大两倍，单目所看到的像是一样的。同样的，把这个大小乘以任意倍数，我们都将看到一样的景象。</p>
</blockquote>
<p>单目 SLAM 估计的轨迹和地图，将与真实的轨迹、地图，相差一个因子，也就是所谓的<strong>尺度(Scale)<strong>。由于单目 SLAM 无法仅凭图像确定这个真实尺度，所以又称为</strong>尺度不确定性</strong>。</p>
<h4 id="双目相机"><a href="#双目相机" class="headerlink" title="双目相机"></a>双目相机</h4><p>双目相机由两个单目相机组成，但是这两个相机之间的距离【基线（Baseline）】是已知的。和人的双线比较相似，通过这个基线来估计每个像素的空间距离。</p>
<p>你可以将你的一根手指放在你的鼻子前，分别捂住左右眼，被遮住的背景是不同的。</p>
<p><strong>优点</strong>：距离估计是比较左右眼图像获得的，不依赖其他传感设备，所以室内室外都可以应用。</p>
<p><strong>缺</strong>点：需要<strong>大量计算</strong>才能（不太可靠地）估计每一个像素点的深度值、配置和标定均较为复杂、其深度量程和精度受双目的基线与分辨率所致、计算视差非常耗费计算资源，需要使用GPU和FPGA设备加速。</p>
<h4 id="深度相机"><a href="#深度相机" class="headerlink" title="深度相机"></a>深度相机</h4><p>2010年后兴起，最大特点就是可以通过红外结构光和Time-of- Flight（ToF）原理，像激光传感器那样通过主动向物体发射反射光并接收返回的光（有点类似于回声啊哈哈）测距。</p>
<p><strong>优点</strong>：它不像双目相机通过软件来计算，而是通过物理测量手段，所以计算量小。</p>
<p><strong>缺点</strong>：测量范围窄、噪声大、视野小、易受日光干扰、无法测量投射材质等。</p>
<p>目前常用RGB-D相机：Kinect/Kinect V2、Xtion Pro Live、RealSense等。</p>
<h3 id="2-2-经典视觉SLAM框架"><a href="#2-2-经典视觉SLAM框架" class="headerlink" title="2.2 经典视觉SLAM框架"></a>2.2 经典视觉SLAM框架</h3><p>如下图：</p>
<p>依靠这些算法，我们可以构建一个视觉SLAM系统，使之在正常的工作环境中实时定位和建图。</p>
<img src="/2021/04/03/SLAM14/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2-%E7%AC%AC2%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E8%AE%B2/image-20210403235429941.png" class="" title="视觉SLAM流程图">

<h4 id="2-2-1-传感器信息读取"><a href="#2-2-1-传感器信息读取" class="headerlink" title="2.2.1 传感器信息读取"></a>2.2.1 传感器信息读取</h4><p>主要是为相机图像信息的读取与预处理。</p>
<h4 id="2-2-2-前端视觉里程计（Visual-Odometry，VO）"><a href="#2-2-2-前端视觉里程计（Visual-Odometry，VO）" class="headerlink" title="2.2.2 前端视觉里程计（Visual Odometry，VO）"></a>2.2.2 前端视觉里程计（Visual Odometry，VO）</h4><p><strong>任务</strong>：估算相邻图像间相机的运动，以及局部地图的样子。VO又称前端（Front End）。</p>
<p>在计算机视觉中，根据图像确定相机的运动十分困难。图像在计算机中只是一个数值矩阵，在视觉SLAM中，我们只能看到一个个像素，知道它们是某些空间点在相机的成像平面上投影的结果，所以，为了定量地估计相机运动，必须先<strong>了解相机与空间点的几何关系</strong>。</p>
<p>称其为“里程计”是因为它和实际的里程计一样，只计算相邻时刻的运动，而和过去的信息没有关联。</p>
<p>仅仅通过视觉里程计来估计轨迹，将不可避免地出现<strong>累积漂移</strong>（Accumulating Drift）。这是由于视觉里程计在最简单的情况下只估计两个图像间的运动而造成的，因为每次估计都有一定误差，而由于里程计的工作方式，会将前刻的误差传递到下一刻，经过一段时间的累积后，估计的轨迹将不再准确。</p>
<p>如下图所示。</p>
<blockquote>
<p>比方说，机器人先向左转90度，再向右转了90度。由于误差，我们把第一个90度估计成了89度。那我们就会尴尬地发现，向右转之后机器人的估计位置并没有回到原点。更糟糕的是，即使之后的估计再准确，与真实值相比，都会带上这-1度的误差。</p>
</blockquote>
<img src="/2021/04/03/SLAM14/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2-%E7%AC%AC2%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E8%AE%B2/image-20210405224053208.png" class="" title="漂移误差">



<p>这也就是所谓的<strong>漂移</strong>（Drift）。将会导致我们无法建立一致的地图。</p>
<p>为了解决漂移问题，我们还需要两种技术：<strong>后端优化</strong>和<strong>回环检测</strong>。</p>
<blockquote>
<p><strong>后端优化</strong>更多时候称之为后端。由于主要是用的是优化方法，故称为后端优化。</p>
</blockquote>
<h4 id="2-2-3-后端（非线性）优化"><a href="#2-2-3-后端（非线性）优化" class="headerlink" title="2.2.3 后端（非线性）优化"></a>2.2.3 后端（非线性）优化</h4><p><strong>任务</strong>：处理SLAM过程中的<strong>噪声</strong>问题。</p>
<p>再精确的传感器也会带有误差，除了需要解决前端问题，还要关心这个估计带有多大噪声，是如何传递的，而我们又对当前的估计有多大信心。</p>
<p>后端优化就是如何从这些带有噪声的数据中估计整个系统的<strong>状态</strong>（包括机器人自身的轨迹，也包括地图），以及这个状态估计的不确定性有多大——即为最大后验概率估计（Maximum-a-Posteriori）。</p>
<p><strong>在视觉SLAM中，前端和计算机视觉研究领域更为相关，比如图像的特征提取与匹配等，后端则主要是滤波和非线性优化算法</strong>。</p>
<h4 id="2-2-4-回环检测"><a href="#2-2-4-回环检测" class="headerlink" title="2.2.4 回环检测"></a>2.2.4 回环检测</h4><p>回环检测又称为闭环检测。</p>
<p><strong>任务</strong>：解决位置估计随时间漂移的问题。</p>
<blockquote>
<p>怎么解决呢？假设实际情况下，机器人经过一段时间运动后回到了原点，但是由于漂移，它的位置估计值却没有回到原点。怎么办呢?我们想，如果有某种手段，让机器人知道“回到了原点”这件事，或者把“原点”识别出来，我们再把位置估计值“拉”过去，就可以消除漂移了。这就是所谓的回环检测。</p>
</blockquote>
<p>回环检测和“定位”以及“建图”都有联系。地图存在的主要意义是让机器人知晓自己到过的地方，所以为了实现回环检测，我们需要让机器人具有<strong>识别到过的场景</strong>的能力。</p>
<p>尽量采用机器人自身携带的传感器实现，例如，可以<strong>判断图像间的相似性</strong>来完成回环检测。</p>
<p>检测到回环之后，我们会吧“A和B是同一个点”之类的信息告诉后端优化算法，让后端优化算法根据新信息进行调整消除误差。</p>
<h4 id="2-2-5-建图"><a href="#2-2-5-建图" class="headerlink" title="2.2.5 建图"></a>2.2.5 建图</h4><p><strong>任务</strong>：构建地图。</p>
<p>地图（见下图）是对环境的描述，但是这个描述并不是固定的，需要视SLAM的应用而定。</p>
<img src="/2021/04/03/SLAM14/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2-%E7%AC%AC2%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E8%AE%B2/image-20210405230415212.png" class="" title="不同地图">

<p>对于地图我们有太多的想法和需求，但是建图并没有一个固定的形式和算法。</p>
<p>大体上讲，可以分为<strong>度量地图</strong>和<strong>拓扑地图</strong>。</p>
<h5 id="度量地图"><a href="#度量地图" class="headerlink" title="度量地图"></a>度量地图</h5><p>度量地图强调精确地表示地图中物体的位置关系，通常用稀疏（Sparse）和稠密（Dense）对其分类。</p>
<blockquote>
<p>稀疏地图进行了一定程度的抽象,并不需要表达所有的物体。例如，我们选择一部分具有代表意义的东西，称之为路标(Landmark)，那么一张稀疏地图就是由路标组成的地图，而不是路标的部分就可以忽略掉。相对的，稠密地图着重于建模所有看到的东西。对于定位来说，稀疏路标地图就足够了。而用于导航时，我们往往需要稠密的地图(否则撞上两个路标之间的墙怎么办？)。</p>
<p>稠密地图通常按照某种分辨率，由许多个小块组成。二维度量地图是许多个小格子(Grid)， 三维则是许多小方块(Voxel)。一般地，一个小块含有占据、空闲、未知三种状态，以表达该格内是否有物体。当我们查询某个空间位置时，地图能够给出该位置是否可以通过的信息。这样的地图可以用于各种导.航算法，如A*,D*等等，为机器人研究者们所重视。但是我们也看到，这种地图需要存储每一个格点的状态，耗费大量的存储空间，而且多数情况下地图的许多细节部分是无用的。另一方面，大规模度量地图有时会出现一致性问题。 很小的一点转向误差， 可能会导致两间屋子的墙出现重叠，使得地图失效。</p>
</blockquote>
<h5 id="拓扑地图"><a href="#拓扑地图" class="headerlink" title="拓扑地图"></a>拓扑地图</h5><p>相比于度量地图的精确性，拓扑地图更强调地图元素之间的关系。</p>
<blockquote>
<p>拓扑地图是一个图(Graph)， 由节点和边组成，只考虑节点间的连通性，例如A, B点是连通的，而不考虑如何从A点到达B点的过程。它放松了地图对精确位置的需要，去掉地图的细节问题,是一种更为紧凑的表达方式。然而，拓扑地图不擅长表达具有复杂结构的地图。如何对地图进行分割形成结点与边，又如何使用拓扑地图进行导航与路径规划，仍是有待研究的问题。</p>
</blockquote>
<h3 id="2-3-SLAM中的数学表达"><a href="#2-3-SLAM中的数学表达" class="headerlink" title="2.3 SLAM中的数学表达"></a>2.3 SLAM中的数学表达</h3><p>我们要用数学语言来描述SLAM的过程，要用到一些变量和公式。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>《视觉SLAM十四讲》</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>书籍</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>hellohoo</title>
    <url>/2021/03/03/hellohoo/</url>
    <content><![CDATA[<p>这是我的博客的第一篇，是向大家问好，希望以后可以在这个blog上记录我的学习以及一些我突如奇其来的灵感，有些东西是循序递进的，所以一起加油吧。</p>
]]></content>
      <categories>
        <category>胡说</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>《视觉SLAM十四讲 第2版》学习笔记 第1讲</title>
    <url>/2021/04/02/SLAM14/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2-%E7%AC%AC2%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E8%AE%B2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>开始是成功的左括号。——Hoohoo</p>
</blockquote>
<span id="more"></span>

<p>最近开始学习CV领域，因为老师想让我做医学影像的三维重建，依我理解，医学影像的三维重建就是面绘制、体绘制之类的，使用VTK、ITK工具包完成，也询问了一些学长等专业人士，得知这边并不好出成果，好出成果的就是切割、MRI之类的，我并没有很大的兴趣，而且老师希望我继续做，我只能曲线救国，先学学重建之类的知识，也就是计算机视觉这方面的，而非专一的医学影像方向。</p>
<p>并且一定要学习的话，反正都是从0开始，就先学着吧！</p>
<p>最近在看的一篇论文，十年前的一篇开山之作，就是SLAM中的前端技术，所以在推荐下，就开始学习高翔等著的《视觉SLAM十四讲 从理论到实践》第2版。</p>
<h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><p>第一讲是预备知识，介绍本书的基本信息。</p>
<blockquote>
<p>本书代码：<a href="https://github.com/gaoxiang12/slambook2">https://github.com/gaoxiang12/slambook2</a></p>
</blockquote>
<p><strong>SLAM：</strong> <strong>S</strong>imultaneous <strong>L</strong>ocalization <strong>a</strong>nd <strong>M</strong>apping （<strong>同时定位与地图构建</strong>）的缩写。指搭载特定传感器的主体，在没有环境先验信息情况下，于运动过程中建立环境的模型，同时估计自己的运动。如果传感器主要是相机，则称为“视觉SLAM”。</p>
<p>所需前备知识：</p>
<ul>
<li><p>高等数学、<strong>线性代数</strong>(!!!!)、概率论</p>
</li>
<li><p>C++语言基础</p>
</li>
<li><p>Linux基础</p>
</li>
</ul>
<p>需要用到的主要库：<code>Eigen</code>、<code>OpenCV</code>、<code>PCL</code>、<code>g2o</code>、<code>Ceres</code>等。</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li><p>有线性方程 Ax = b，当我们知道 A, b，想要求解 x 时，如何求解？这对 A 和 b 需 要哪些条件？提示:从 A 的维度和秩角度来分析。</p>
<p><label style="color:#f5222d"><strong>答：</strong></label></p>
<ul>
<li>当R(A) = R(A,b) = n时，有唯一解。</li>
<li>当R(A) = R(A,b) &lt; n时，有多解。</li>
<li>当R(A) &lt; R(A,b) 时，无解。</li>
</ul>
<p>// 其中R()为秩的个数，n为未知数的个数。</p>
</li>
<li><p>高斯分布是什么？它的一维形式是什么样子？它的高维形式是什么样子？</p>
<p><label style="color:#f5222d"><strong>答：</strong></label> 高斯分布又称为正态分布===</p>
</li>
<li><p>你知道 C++ 的类吗？你知道 STL 吗？你使用过它们吗？</p>
<p><label style="color:#f5222d"><strong>答：</strong></label>知道一些类，使用过STL。</p>
</li>
<li><p>你以前怎样书写 C++ 程序？(你完全可以说只在 VC6.0 下写过 C++ 工程，只要你 有写 C++ 和 C 语言经验就行。)</p>
<p><label style="color:#f5222dd"><strong>答：</strong></label>刚开始使用<code>CodeBlock</code>写C语言，后来使用<code>Clion</code>，前段时间做VTK，也用过一段时间<code>Visual Studio</code>。</p>
</li>
<li><p>你知道 C++11 标准吗？其中哪些新特性你之前听说过或使用过？有没有其他的标准？</p>
<p><label style="color:#f5222d"><strong>答：</strong></label>====</p>
</li>
<li><p>你知道 Linux 吗？你有没有至少使用过其中之一(安卓不算)，比如 Ubuntu？</p>
<p><label style="color:#f5222d"><strong>答：</strong></label> 知道。用过MacOS、Windows、CentOS、Federa、Ubuntu。</p>
</li>
<li><p>Linux 的目录结构是什么样的？你知道哪些基本命令，比如 ls, cat 等等？</p>
<p><label style="color:#f5222d"><strong>答：</strong></label> Linux下的目录结构主要是由<code>/</code>延伸。</p>
<p>一些命令：<code>ls</code>、<code>ll</code>、<code>mkdir</code>、<code>rm</code>、<code>tar</code>、<code>vim</code>、<code>pwd</code>、<code>which</code>…</p>
</li>
<li><p>如何在 Ubuntu 中安装软件(不打开软件中心的情况下)？这些软件被安装在什么地方？当我只知道模糊的软件名称(比如我想要装一个 eigen 名称的库)，我应该如何安装它？</p>
<p><label style="color:#f5222d"><strong>答：</strong></label> <code>apt-get install</code>，===</p>
</li>
<li><p>*花一个小时学习一下Vim，因为你迟早会用它。你可以在终端中输入vimtutor阅 读一遍所有内容。我们不需要你非常熟练地操作它，只要在学习本书的过程中使用它 键入代码即可。不要在它的插件上浪费时间，不要想着把 vim 用成 IDE，我们只用 它做文本编辑的工作。</p>
<p><label style="color:#f5222d"><strong>答：</strong></label>Vim！！！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>《视觉SLAM十四讲》</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>书籍</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
